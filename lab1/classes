#include <iostream>
#include <vector>
#include <cstdarg>
#include <cmath>

class Dot {
public:
    int x;
    int y;

    explicit Dot(int x = 0, int y = 0) : x(x), y(y) {}

    Dot(const Dot &dot) : x(dot.x), y(dot.y) {}

    ~Dot() {}

    Dot & operator = (const Dot &dot) {
        x = dot.x;
        y = dot.y;

        return *this;
    }

};

class c2 : public Dot {
    using Dot::operator=;
};

class Polyline {

public:

    Polyline(int num, ...) {
        int x = 0, y = 0;
        Dot a;
        va_list args;
        va_start(args, num);
        count_unit = num - 1;
        while (num--) {
            x = va_arg(args, int);
            y = va_arg(args, int);
            a.x = x; a.y = y;
            coordinate.push_back(a);
        }
        va_end(args);
    }

    Polyline(const Polyline &poly) {
        count_unit = poly.count_unit;
        coordinate = poly.coordinate;
    }

    Polyline & operator = (const Polyline &poly) {
        count_unit = poly.count_unit;
        coordinate = poly.coordinate;
        return *this;
    }

    int perimeter() {
        int per = 0, unit = 0;
        for (int i = 0; i < count_unit; i++) {
            unit = sqrt(pow((coordinate[i].x - coordinate[i + 1].x), 2) + pow((coordinate[i].y - coordinate[i + 1].y), 2));
            per += unit;
        }
        return per;
    }

private:
    int count_unit;
    std::vector <Dot> coordinate;

};

class Closed_polyline {

public:

    Closed_polyline(int num, ...) {
        int x = 0, y = 0;
        Dot a;
        va_list args;
        va_start(args, num);
        count_unit = num;
        while (num--) {
            x = va_arg(args, int);
            y = va_arg(args, int);
            a.x = x; a.y = y;
            coordinate.push_back(a);
        }
        va_end(args);
    }

    Closed_polyline(const Closed_polyline &c_poly) {
        count_unit = c_poly.count_unit;
        coordinate = c_poly.coordinate;
    }

    Closed_polyline & operator = (const Closed_polyline &c_poly) {
        count_unit = c_poly.count_unit;
        coordinate = c_poly.coordinate;
        return *this;
    }

    int perimeter() {
        int per = 0, unit = 0;
        for (int i = 0; i < count_unit - 1; i++) {
            unit = sqrt(pow((coordinate[i].x - coordinate[i + 1].x), 2) + pow((coordinate[i].y - coordinate[i + 1].y), 2));
            per += unit;
        }
        unit = sqrt(pow((coordinate[0].x - coordinate[count_unit - 1].x), 2) + pow((coordinate[0].y - coordinate[count_unit - 1].y), 2));
        per+=unit;
        return per;
    }

protected:
    int count_unit;
    std::vector <Dot> coordinate;

};

class r_polygon {
public:
    r_polygon(int num, ...) {
        int x = 0, y = 0;
        Dot a;
        va_list args;
        va_start(args, num);
        count_unit = num;
        while (num--) {
            x = va_arg(args, int);
            y = va_arg(args, int);
            a.x = x; a.y = y;
            coordinate.push_back(a);
        }
        va_end(args);
    }

    r_polygon(const r_polygon &polyg) {
        count_unit = polyg.count_unit;
        coordinate = polyg.coordinate;
    }

    r_polygon & operator = (const r_polygon &polyg) {
        count_unit = polyg.count_unit;
        coordinate = polyg.coordinate;
        return *this;
    }

    int perimeter() {
        int per = 0, unit = 0;
        for (int i = 0; i < count_unit - 1; i++) {
            unit = sqrt(pow((coordinate[i].x - coordinate[i + 1].x), 2) + pow((coordinate[i].y - coordinate[i + 1].y), 2));
            per += unit;
        }
        unit = sqrt(pow((coordinate[0].x - coordinate[count_unit - 1].x), 2) + pow((coordinate[0].y - coordinate[count_unit - 1].y), 2));
        per+=unit;
        return per;
    }

    float area() {
        float s = 0;
        for (int i = 0; i < count_unit; i++) {
            if (i == 0)
                s += coordinate[i].x * (coordinate[i + 1].y - coordinate[count_unit - 1].y);
            else if (i == count_unit - 1)
                s += coordinate[i].x * (coordinate[0].y - coordinate[i - 1].y);
            else s += coordinate[i].x * (coordinate[i + 1].y - coordinate[i - 1].y);
        }
        s /= 2;
        return abs(s);
    }

private:
    int count_unit;
    std::vector <Dot> coordinate;
};

class Triangle {
public:
    explicit Triangle(int x1 = 0, int y1 = 0, int x2 = 0, int y2 = 0, int x3 = 0, int y3 = 0 ) {
        coordinate[0].x = x1; coordinate[0].y = y1;
        coordinate[1].x = x2; coordinate[1].y = y2;
        coordinate[2].x = x3; coordinate[2].y = y3;
    }

    Triangle(const Triangle &tri) {
        for (int i = 0; i < 3; i++) coordinate[i] = tri.coordinate[i];
    }

    Triangle & operator = (const Triangle &tri) {
        for (int i = 0; i < 3; i++) coordinate[i] = tri.coordinate[i];
        return *this;
    }

    int perimeter() {
        int per = 0;
        per += sqrt(pow((coordinate[0].x - coordinate[1].x), 2) + pow((coordinate[0].y - coordinate[1].y), 2));
        per += sqrt(pow((coordinate[1].x - coordinate[2].x), 2) + pow((coordinate[1].y - coordinate[2].y), 2));
        per += sqrt(pow((coordinate[0].x - coordinate[2].x), 2) + pow((coordinate[2].y - coordinate[0].y), 2));
        return per;
    }

    float area() {
        float s = (coordinate[1].x - coordinate[0].x)*(coordinate[2].y - coordinate[0].y) ;
        s -= (coordinate[2].x - coordinate[0].x)*(coordinate[1].y - coordinate[0].y);
        s/=2;
        return abs(s);
    }

private:
    Dot coordinate[3];
};


class Trapeze {
public:

    explicit Trapeze(int x1 = 0, int y1 = 0, int x2 = 0, int y2 = 0, int x3 = 0, int y3 = 0, int x4 = 0, int y4 = 0) {
//        int k1 = (y3 - y2)/(x3 - x2);
//        int k2 = (y4 - y1)/(x4 - x1);
//        if (k1 == k2) {
            coordinate[0].x = x1;
            coordinate[0].y = y1;
            coordinate[1].x = x2;
            coordinate[1].y = y2;
            coordinate[2].x = x3;
            coordinate[2].y = y3;
            coordinate[3].x = x4;
            coordinate[3].y = y4;
//        }
//        else st
    }

    Trapeze(const Trapeze &tra) {
        for (int i = 0; i < 4; i++) coordinate[i] = tra.coordinate[i];
    }

    Trapeze & operator = (const Trapeze &tri) {
        for (int i = 0; i < 4; i++) coordinate[i] = tri.coordinate[i];
        return *this;
    }

    int perimeter() {
        int per = 0;
        per += sqrt(pow((coordinate[0].x - coordinate[1].x), 2) + pow((coordinate[0].y - coordinate[1].y), 2));
        per += sqrt(pow((coordinate[1].x - coordinate[2].x), 2) + pow((coordinate[1].y - coordinate[2].y), 2));
        per += sqrt(pow((coordinate[3].x - coordinate[2].x), 2) + pow((coordinate[3].y - coordinate[2].y), 2));
        per += sqrt(pow((coordinate[0].x - coordinate[3].x), 2) + pow((coordinate[0].y - coordinate[3].y), 2));

        return per;
    }

    float area() {
        float s = 0;
        for (int i = 1; i < 3; i++) {
            s += coordinate[i].x*(coordinate[i + 1].y - coordinate[i - 1].y);
        }
        s+=coordinate[0].x*(coordinate[1].y - coordinate[3].y);
        s+=coordinate[3].x*(coordinate[0].y - coordinate[2].y);

        s/=2;
        return abs(s);
    }

private:
    Dot coordinate[4];
};

class right_polygon {
public:
    right_polygon(int num, ...) {
        int x = 0, y = 0;
        Dot a;
        va_list args;
        va_start(args, num);
        count_unit = num;
        while (num--) {
            x = va_arg(args, int);
            y = va_arg(args, int);
            a.x = x; a.y = y;
            coordinate.push_back(a);
        }
        va_end(args);
    }

    right_polygon(const right_polygon &r_polyg) {
        count_unit = r_polyg.count_unit;
        coordinate = r_polyg.coordinate;
    }

    right_polygon & operator = (const right_polygon &r_polyg) {
        count_unit = r_polyg.count_unit;
        coordinate = r_polyg.coordinate;
        return *this;
    }

    int perimeter() {
        int per = 0, unit = 0;
        for (int i = 0; i < count_unit - 1; i++) {
            unit = sqrt(pow((coordinate[i].x - coordinate[i + 1].x), 2) + pow((coordinate[i].y - coordinate[i + 1].y), 2));
            per += unit;
        }
        unit = sqrt(pow((coordinate[0].x - coordinate[count_unit - 1].x), 2) + pow((coordinate[0].y - coordinate[count_unit - 1].y), 2));
        per+=unit;
        return per;
    }

    float area() {
        float s = 0;
        for (int i = 0; i < count_unit; i++) {
            if (i == 0)
                s += coordinate[i].x * (coordinate[i + 1].y - coordinate[count_unit - 1].y);
            else if (i == count_unit - 1)
                s += coordinate[i].x * (coordinate[0].y - coordinate[i - 1].y);
            else s += coordinate[i].x * (coordinate[i + 1].y - coordinate[i - 1].y);
        }
        s /= 2;
        return abs(s);
    }

private:
    int count_unit;
    std::vector <Dot> coordinate;
};




int main() {
    Triangle ex( 2, 2, 5, 6, 8, 2);
    float p = ex.area();
    std::cout << p;

    return 0;
}
